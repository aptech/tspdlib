
/*
**> gls
**  Reference:
**  Elliott, G., Rothenberg, T.J., Stock, J.H. (1996). 
**  Efficient tests for an autoregressive unit root. 
**  Econometrica 64,813–836.
**
**  Ng, S., Perron, P. (2001). 
**  Lag length selection and the construction of unit root tests with good size and power. 
**  Econometrica 69,1519–1554.
**
**
**  Format:  {GLStau, p, cvGLS}   = DFGLS(y,model,pmax,ic);
**           {Pt,lrv, cvPT}       = ERSpt(y,model,l,varm);
**           {MZa, MZt, MSB, MPT, cvMZA, cvMZt, cvMSB, cvMPT} = MGLS(y,model,l,varm);
**
**  Input:   Y	     -  Nx1 matrix, data,
**           model   - 	1 = model with constant
**                      2 = model with constant and trend
**           pmax    -  Maximum number of lags for Dy; 0=no lags
**           ic      -  Information Criterion:
**                      1=Akaike
**                      2=Schwarz
**                      3=t-stat significance
**           l       -  Bandwidth for spectral window
**           varm    -  Long-run consistent variance estimation method
**                      1 = iid;
**                      2 = Bartlett
**                      3 = Qudratic Spectral (QS);
**                      4 = SPC with Bartlett /see (Sul, Phillips & Choi, 2005)
**                      5 = SPC with QS;
**                      6 = Kurozumi with Bartlett
**                      7 = Kurozumi with QS
**                      Updated from Carrion-i-Silvestre & Sanso (2007) GAUSS codes.
**                      See:
**                      Carrion-i-Silvestre, J. L., & Sansó, A. (2006).
**                      A guide to the computation of stationarity tests.
**                      Empirical Economics, 31(2), 433.
**
**  Output:  GLStau  - DF-GLS statistic
**			 p       - number of lags for DF-GLS statistic
**			 PT      - Pt statistic
**           Mza     - MZalpha statistic
**           Mzt     - MZt statistic
**           MSB     - MSB statistic
**           MPT     - MPT statistic
**           lrv     - Long-run variance
**			 cv      - 1, 5, and 10 percent critical values

**  Author: Saban Nazlioglu
-- The author makes no performance guarantees.
-- for public non-commercial use only.
-- for any bugs, please send e-mail to snazlioglu@pau.edu.tr
**
*/

/*17 July 2016*/

proc(3) = DFGLS(y, model, pmax, ic);
    local t, taup, aicp, sicp, tstatp, c, z;
    local a, ya, za, bhat, ygls, dy, ly, dc, dt, n, k, LL;
    local p,lmat,j,dep,y1,ldy,sbt,trnd,x,tau;
    local b,e1,sig2,se,ssr, cv;
    
    t = rows(y);
    taup = zeros(pmax + 1, 1);
    aicp = zeros(pmax + 1, 1);
    sicp = zeros(pmax + 1, 1);
    tstatp = zeros(pmax + 1, 1);
    
    if model == 1;
        c = -7.00;
        z = ones(t, 1);
    endif;
    
    if model == 2;
        c = -13.50;
        z = ones(t, 1)~seqa(1, 1, t);
    endif;
    
    a = 1 + c/t;
    ya = zeros(t, 1);
    za = zeros(t, cols(z));
    ya[1:1, 1] = y[1:1, 1];
    za[1:1, .] = z[1:1, .];
    ya[2:t, 1] = y[2:t, 1]-a*y[1:t-1, 1];
    za[2:t, .] = z[2:t, .] - a * z[1:t-1, .];
    
    // Constructing GLS detrended series
    bhat = inv(za'za) * za'ya;
    
    // GLS trending data
    ygls = y - z * bhat;      
    
    t = rows(ygls);
    dy = diff(ygls, 1);
    ly = lagn(ygls, 1);
    
    // Deterministic term=constant
    dc = ones(t, 1);     
    
    // Deterministic term=trend
    dt=seqa(1, 1, t);     
    
    p = 0;
    do while p <= pmax;
        lmat = zeros(rows(dy), p + 1);
        j = 1;
        
        do while j <= p;
            lmat[., j] = lagn(dy, j);
            j = j + 1;
        endo;
        
        dep = trimr(dy, p + 1, 0);
        y1 = trimr(ly, p + 1, 0);
        ldy = trimr(lmat, p + 1, 0);
        sbt = trimr(dc, p + 1, 0);
        trnd = trimr(dt, p + 1, 0);
        
        if p == 0;
            x = y1;
        elseif p > 0;
            x = y1~ldy[., 1:p];
        endif;
        
        {b, e1, sig2, se, ssr} = myols(dep, x);
        taup[p+1] = b[1]/se[1];
        
        n = rows(x);
        k = cols(x);
        
        // Log-likelihood
        LL = -n/2 * (1 + ln(2 * pi) + ln(e1'e1/n));           
        aicp[p+1] = (2 * k - 2 * LL)/n;
        sicp[p+1] = (k * ln(n) - 2 * LL)/n;
        tstatp[p+1] = abs(b[cols(x)]/se[cols(x)]);
        p = p + 1;
    endo;
    
    p   = _get_lag(ic, pmax, aicp, sicp, tstatp);
    tau = taup[p];
    cv  = _get_cv_dfgls(model, T);
    
    retp(tau, p - 1, cv);
endp;



proc(1) = _get_cv_dfgls(model, T);
    local crit, cv;

// Critical Values (see Fuller, 1976, Table 5.3)    
    if model == 1;
        crit = {-2.62 -1.95 -1.61,      @ T = 50  @
                -2.60 -1.95 -1.61,      @ T = 100 @
                -2.58 -1.95 -1.62,      @ T = 200 @        
                -2.58 -1.95 -1.62};     @ T = inf @   
    endif;

// Critical Values (see Elliot et al., 1996, Table I)   
    if model == 2;
        crit = {-3.77 -3.19 -2.89,      @ T = 50  @
                -3.58 -3.03 -2.74,      @ T = 100 @
                -3.46 -2.93 -2.64,      @ T = 200 @        
                -3.48 -2.89 -2.57};     @ T = inf @   
    endif;

    
    if             T <= 50;     cv = crit[1,.]; endif;
    if 50  < T and T <= 100;    cv = crit[2,.]; endif;    
    if 100 < T and T <= 200;    cv = crit[3,.]; endif;    
    if 200 < T             ;    cv = crit[4,.]; endif;   

retp(cv);
endp;


proc(3) = ERSpt(y, model, l, varm);
    local t, dy, ly, dc, dt, dep, y1, sbt, trnd, x, tau, g0, lrv;
    local c, a, ya, za, ba, u, SSRa, SSR1, PT;
    local b, e1, s2, se, ssr, z, cv;
    
    t = rows(y);
    dy = diff(y, 1);
    ly = lagn(y, 1);
    
    // Deterministic term=constant
    dc = ones(t, 1);  

    // Deterministic term=trend
    dt = seqa(1, 1, t);     
    
    if model == 1;
        z = ones(t, 1);
    endif;
    
    if model == 2;
        z = ones(t, 1)~seqa(1, 1, t);
    endif;
    
    dep = trimr(dy, 1, 0);
    y1 = trimr(ly, 1, 0);
    x = trimr(z, 1, 0);
    
    if model == 1;
        x = y1~x;
    endif;
    
    if model == 2;
        x = y1~x;
    endif;
    
    {b, e1, s2, se, ssr} = myols(dep, x);
    tau = b[1]/se[1];
    t = rows(e1);
    
    // Residual variance as in Eviews
    g0 = (t - cols(x)) * s2 * 1/t;        
    
    // Long-run variance with Barlett
    if varm == 1;
        lrv = ssr/t;
    elseif varm == 2;
        lrv = bartlett(e1, l);
    elseif varm == 3;
        lrv = qs(e1,l);
    elseif varm == 4;
        lrv = spc_bartlett(e1, l);
    elseif varm == 5;
        lrv = spc_qs(e1, l);
    elseif varm == 6;
        lrv = kurozumi_bartlett(e1);
    elseif varm == 7;
        lrv = kurozumi_qs(e1);
    endif;
    
    t = rows(y);
    
    if model == 1;
        c = -7.00;
        z = ones(t, 1);
    endif;
    
    if model == 2;
        c = -13.50;
        z = ones(t, 1)~seqa(1, 1, t);
    endif;
    
    // Estimation on transformed data
    a = 1 + c/t;
    ya = zeros(t, 1);
    za = zeros(t, cols(z));
    ya[1:1, 1] = y[1:1, 1];
    za[1:1, .] = z[1:1, .];
    ya[2:t,1] = y[2:t, 1] - a * y[1:t-1, 1];
    za[2:t,.] = z[2:t, .] - a * z[1:t-1, .];
    ba = ya/za;
    u = ya - za * ba;
    SSRa = u'u;
    
    // Estimation on untransformed data
    a = 1;
    ya = zeros(t, 1);
    za = zeros(t, cols(z));
    ya[1:1, 1] = y[1:1, 1];
    za[1:1, .] = z[1:1, .];
    ya[2:t, 1] = y[2:t, 1] - a * y[1:t-1, 1];
    za[2:t, .] = z[2:t, .] - a * z[1:t-1, .];
    ba = ya/za;
    u = ya - za * ba;
    SSR1 = u'u;
    
    // Point optimal test
    PT = (SSRa - (1 + c/t) * SSR1)/lrv;
    cv = _get_cv_erspt(model, T);
    
    retp(PT, lrv, cv);
endp;

proc(1) = _get_cv_erspt(model, T);
    local crit, cv;

// Critical Values (see Fuller, 1976, Table 5.3)    
    if model == 1;
        crit = {1.87 2.97 3.91,      @ T = 50  @
                1.95 3.11 4.17,      @ T = 100 @
                1.91 3.17 4.33,      @ T = 200 @        
                1.99 3.26 4.48};     @ T = inf @   
    endif;

// Critical Values (see Elliot et al., 1996, Table I)   
    if model == 2;
        crit = {4.22 5.72 6.77,      @ T = 50  @
                4.26 5.64 6.79,      @ T = 100 @
                4.05 5.66 6.86,      @ T = 200 @        
                3.96 5.62 6.89};     @ T = inf @   
    endif;

    
    if             T <= 50;     cv = crit[1,.]; endif;
    if 50  < T and T <= 100;    cv = crit[2,.]; endif;    
    if 100 < T and T <= 200;    cv = crit[3,.]; endif;    
    if 200 < T             ;    cv = crit[4,.]; endif;   

retp(cv);
endp;

proc(8) = MGLS(y, model, l, varm);
    local t, c, a, ya, za, pt, fo, bhat, z;
    local ygls, yd, tt, k, mza, msb, mzt, mpt;
    local cv, cvMZA, cvMZt, cvMSB, cvMPT;
    
    t = rows(y);
    
    if model == 1;
        c = -7.00;
        z = ones(t, 1);
    endif;
    
    if model == 2;
        c = -13.50;
        z = ones(t, 1)~seqa(1, 1, t);
    endif;
    
    a = 1 + c/t;
    ya = zeros(t, 1);
    za = zeros(t, cols(z));
    ya[1:1, 1] = y[1:1, 1];
    za[1:1, .] = z[1:1, .];
    ya[2:t, 1] = y[2:t, 1] - a * y[1:t-1, 1];
    za[2:t, .] = z[2:t, .] - a * z[1:t-1, .];
    
    {PT, fo, cv} = ERSpt(y, model, l, varm);
    
    // constructing GLS detrended series
    bhat = inv(za'za) * za'ya;
    
    // GLS trending data
    ygls = y - z * bhat;                        
    yd = lagn(ygls, 1);
    yd = trimr(yd, 1, 0);
    tt = rows(yd);
    K  = sumc(yd^2)/tt^2;
    MZa = (tt^-1 * ygls[t]^2 - fo)/(2 * k);
    MSB = (k/fo)^(1/2);
    MZt = MZa * MSB;
    
    if model == 1;
        MPT = (c^2 * k - c * t^-1 * ygls[t]^2)/fo;
    endif;
    
    if model == 2;
        MPT = (c^2 * k + (1 - c) * t^-1 * ygls[t]^2)/fo;
    endif;

    // Critical Values (see Ng & Perron, 2001, Table I)
    if  model == 1;
        cvMZa = -13.8  ~ -8.1   ~ -5.7;
        cvMZt =  -2.58 ~ -1.98  ~ -1.62;
        cvMSB =  0.174 ~  0.233 ~ 0.275;
        cvMPT =  1.78  ~  3.17  ~ 4.45;
    endif;

    if  model == 2;
        cvMZa = -23.8  ~ -17.3   ~ -14.2;
        cvMZt =  -3.42 ~  -2.91  ~  -2.62;
        cvMSB =  0.143 ~  0.168  ~ 0.185;
        cvMPT =  4.030 ~  5.480  ~ 6.670;
    endif;
    
    retp(Mza, MZt, MSB, MPT, cvMZA, cvMZt, cvMSB, cvMPT);
endp;
