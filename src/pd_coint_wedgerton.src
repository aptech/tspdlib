/*
** panellmcoint.prg was written by Joakim Westerlund, Department of Economics, Lund University.
** Contact info:  joakim.westerlund@nek.lu.se
**
** The code can be used freely as long as proper reference is given. No performance
** guarantee is made. Bug reports are welcome.
*/
proc (3) = pd_coint_wedgerton(y, x, mod, ...);
    local t, tr, p, q, dft_p, brks, max_f, lmn, nf;
    
    t = rows(y);
    
    // Lags
    dft_p  = int(4*(t/100)^(2/9));
    
    // Get dynamic arguments
    { mod, p, q, tr, max_f } = dynargsGet(1|5, 1, dft_p, dft_p, 0.1, 5);
    
    // Find break points
    brks  = __pd_coint_wedgerton_br(y, x, tr, p, mod);
    
    // Estimate test statistic
    { lmn, nf } = __pd_coint_wedgerton_fact(y, x, brks, p, q, mod, max_f);
    
    retp(brks, lmn, nf);
endp;


proc (1) = __pd_coint_wedgerton_br(y, x, tr, p, mod);
    local t, n, i, br, t1, t2, j, ssr;
    
    t = rows(y);
    n = cols(y);
    
    i  = 1;
    br = zeros(1, n);
    t1 = round(tr*t);
    t2 = round((1-tr)*t);
    do while i <= n;
        
        j   = t1;
        ssr = zeros(t,1);
        do while j <= t2;
            ssr[j] = __pd_coint_ssr(y[.,i], x[.,i], j, mod);
            j      = j + 1;
        endo;
        
        br[i] = __pd_coint_minpr(ssr[t1:t2]) + t1 - 1;
        
        i = i + 1;
    endo;
    
    retp(br);
endp;


proc (2) = __pd_coint_wedgerton_fact(y, x, br, p, q, mod, max);
    local t, n, i, de, z, dz, dy, dx, nf, f, l, d, s0, sl, ds, v, u, v0, vl, zt, za;
    
    t = rows(y);
    n = cols(y);
    
    i = 1;
    de = zeros(t-1,n);
    do while i <= n;
        
        z       = __pd_coint_dum(x[.,i], br[i], mod);
        dz      = __pd_diff_west(z, 1);
        dy      = __pd_diff_west(y[.,i], 1);
        dx      = (__pd_diff_west(x[.,i],1)~dz);
        de[.,i] = (eye(t-1) - dx*inv(dx'dx)*dx')*dy;
        
        i = i + 1;
    endo;
    
    i     = 1;
    zt    = 0;
    za    = 0;
    de    = (zeros(1,n)|de);
    if max eq 0;
        nf    = 0;
        f     = zeros(t, n);
    else;
        nf    = __pd_coint_fact(de, max);
        { f, l } = __pd_coint_prin(de, nf);
        f     = cumsumc(f*l');
    endif;
    do while i <= n;
        
        z  = __pd_coint_dum(x[.,i], br[i], mod);
        dz = __pd_diff_west(z, 1);
        dx = (__pd_diff_west(x[.,i],1)~dz);
        dy = __pd_diff_west(y[., i], 1);
        d  = inv(dx'dx)*(dx'dy);
        s0 = y[., i] - (y[1, i] - (x[1, i]~z[1, .])*d) - (x[., i]~z)*d  - f[., i];
        ds = __pd_diff_west(s0, 1);
        sl = (s0[p+1:t-1, .]~__pd_lagp(ds, p)~dz[p+1:t-1, 1]);
        ds = ds[p+1:t-1];
        d  = inv(sl'sl)*sl'ds;
        u  = ds - sl*d;
        v0 = __pd_lrvar(u, 0);
        vl = __pd_lrvar(ds, q);
        v  = sqrt(diag(v0*inv(sl'sl)));
        
        zt = zt + (d[1]/v[1]);
        za = za + ((t-p-1)*d[1])*sqrt(vl/v0);
        
        i = i + 1;
    endo;
    
    zt = sqrt(n)*(zt/n+1.9675)/sqrt(0.3301);
    za = sqrt(n)*(za/n+8.4376)/sqrt(25.8964);
    
    retp((zt~za), nf);
endp;

proc(1) = __pd_coint_fact(e, nf);
    local t, n, pen, cr, k, s, smax, u, f, lam;
    
    t       = rows(e);
    n       = cols(e);
    { f, lam } = __pd_coint_prin(e, nf);
    u       = e - f*lam';
    smax    = sumc(sumc(u.^2))/(n*t);
    
    k    = 1;
    cr   = zeros(nf,1);
    do while k <= nf;
        
        { f, lam } = __pd_coint_prin(e, k);
        u       = e - f*lam';
        s       = sumc(sumc(u.^2))/(n*t);
        pen     = (n+t)/(n*t)*log(minc(n|t));
        cr[k]   = log(s) + k*pen;
        
        k = k + 1;
    endo;
    
    cr = sortc(seqa(1, 1, rows(cr))~cr,2);
    
    retp(cr[1, 1]);
endp;


proc (2) = __pd_coint_prin(e, nf);
    local t,n,f0,v,f,lam;
    
    t = rows(e);
    n = cols(e);
    
    if n > t;
        { f0, v, f }  = svd1(e*e');
        f         = f0[.,1:nf]*sqrt(t);
        lam       = (e'f)/t;
    else;
        
        {f0,v,f}  = svd1(e'e);
        lam       = f0[.,1:nf]*sqrt(n);
        f         = (e*lam)/n;
    endif;
    
    retp(f, lam);
endp;


proc (1) = __pd_coint_detm(x,br,mod);
    local t, d, z;
    
    t = rows(x);
    
    // Set initial z
    z = seqa(1, 1, t);
    
    // Break points
    if br ne 0;
        d = (zeros(br, 1)|ones(t-br, 1));
    endif;
    
    // Add dummies for model two
    if mod eq 2;
        if br ne 0;
            z = z~(d.*x);
        endif;
    endif;
    
    retp(z);
endp;

proc (1) = __pd_coint_dum(x, br, model);
    local t, d, z;
    
    t = rows(x);
    
    // Set initial z
    z = seqa(1, 1, t);
    
    if br ne 0;
        d = (zeros(br,1)|ones(t-br,1));
    endif;
    
    
    if br ne 0;
        if model eq 1;
            z = z~d;
        elseif model eq 2;
            z =  z~d~(d.*x);
        endif;
    endif;
    
    retp(z);
endp;


proc (1) = __pd_coint_ilt(y, x, br, p, mod);
    local d, u, za, zt, t, dy, dx, v, z, dz, s0, sl, ds, v0, vl;
    
    t = rows(y);
    
    z  = __pd_coint_dum(x, br, mod);
    dz = __pd_diff_west(z, 1);
    dx = (__pd_diff_west(x, 1)~dz);
    dy = __pd_diff_west(y, 1);
    d  = inv(dx'dx)*(dx'dy);
    s0 = y - (y[1] - (x[1,.]~z[1,.])*d) - (x~z)*d;
    ds = __pd_diff_west(s0,1);
    sl = (s0[p+1:t-1,.]~__pd_lagp(ds,p)~dz[p+1:t-1,.]);
    ds = ds[p+1:t-1];
    d  = inv(sl'sl)*sl'ds;
    u  = ds - sl*d;
    v0 = __pd_lrvar(u,0);
    vl = __pd_lrvar(ds,p);
    v  = sqrt(diag(v0*inv(sl'sl)));
    
    zt = d[1]/v[1];
    za = ((t-p-1)*d[1])*sqrt(vl/v0);
    
    retp(zt~za);
endp;

proc (1) = __pd_coint_ssr(y, x, br, mod);
    local d, u, t, dy, dx, z, dz;
    
    t = rows(y);
    
    z  = __pd_coint_dum(x,br,mod);
    dz = __pd_diff_west(z,1);
    dx = (__pd_diff_west(x,1)~dz);
    dy = __pd_diff_west(y,1);
    d  = inv(dx'dx)*(dx'dy);
    u  = dy - dx*d;
    
    retp(u'u);
endp;

proc (1) = __pd_coint_minpr(x);
    local d,m,i;
    
    i = 1;
    m = 1;
    d = x[1];
    do while i <= rows(x);
        if x[i] < d;
            d = x[i];
        endif;
        i = i+1;
    endo;
    
    i = 2;
    do while i <= rows(x);
        if d == x[i];
            m = i;
            goto stops;
        endif;
        i = i + 1;
    endo;
    
    stops:
        
        retp(m);
endp;

proc __pd_diff_west(x, k);
    if k == 0;
        retp(x) ;
    endif ;
    
    retp(trimr(x, k, 0) - trimr(lagn(x, k), k, 0));
endp;

proc __pd_lrvar(u, k);
    local sl,s0;
    
    sl = __pd_fejer(u, k);
    s0 = (u'u)/rows(u);
    
    retp((s0 + sl + sl'));
endp;

proc (1) = __pd_lagp(x, p);
    local t,i,xl;
    
    t = rows(x);
    
    i  = 1;
    xl = lagn(x, 1);
    do while i < p;
        i  = i + 1;
        xl = (xl~lagn(x, i));
    endo;
    
    retp(trimr(xl, p, 0));
endp;

proc __pd_fejer(uv, k);
    local i, m, a, t1, t2, f;
    
    if k == 0;
        a = 0;
        goto out;
    endif;
    
    i = 1;
    a = 0;
    do until i > k;
        f = i/(k+1);
        m = 1 - f;
        t1 = trimr(uv, i, 0);
        t2 = trimr(lagn(uv, i), i, 0);
        a = a + m*(t1't2);
        i = i + 1;
    endo;
    
    out:
    
    retp(a/rows(uv));
endp;
